{
    "type": "Module",
    "label": "node",
    "text": "import ast\nimport json\nimport os\nimport re\nfrom pathlib import Path\n\nimport asttokens\nimport pathspec\n\nfrom parsnips.swhid import Swhid\n\n\nclass ParsnipsExtractor:\n    \n    def __init__(self, logger, strict=False, repo_root: Path | None = None):\n        self.logger = logger\n        self.strict = strict\n        self.repo_root = Path(repo_root).resolve() if repo_root else None\n\n    def process(self, input_path: Path):\n        input_path = Path(input_path).resolve()\n        if not self.repo_root:\n            self.repo_root = input_path if input_path.is_dir() else input_path.parent\n\n        if input_path.is_file():\n            self._process_file(input_path, force_parsnips_dir=True)\n        elif input_path.is_dir():\n            self._process_directory(input_path)\n        else:\n            self.logger.error(f\"Invalid path: {input_path}\")\n            self._abort()\n\n    def _load_ignore_spec(self) -> pathspec.PathSpec | None:\n        assert self.repo_root is not None\n        ignore_file = self.repo_root / \".parsnipsignore\"\n        if ignore_file.exists():\n            patterns = ignore_file.read_text(encoding='utf-8').splitlines()\n            return pathspec.PathSpec.from_lines(\"gitwildmatch\", patterns)\n        return None\n\n    def _process_directory(self, directory: Path):\n        assert self.repo_root is not None\n\n        ignore_spec = self._load_ignore_spec()\n\n        for root, dirs, files in os.walk(directory, topdown=True, followlinks=False):\n            # Remove ignored directories\n            if ignore_spec:\n                dirs[:] = [d for d in dirs if not ignore_spec.match_file(os.path.relpath(os.path.join(root, d), self.repo_root))]\n            else:\n                dirs[:] = [d for d in dirs if d != '.parsnips']\n\n            for file in files:\n                full_path = Path(root) / file\n                rel_path = full_path.relative_to(self.repo_root)\n                if file.endswith('.py') and (not ignore_spec or not ignore_spec.match_file(str(rel_path))):\n                    self._process_file(full_path)\n\n\n    def _process_file(self, file_path: Path, output_dir=None, force_parsnips_dir=False):\n        self.current_file = file_path\n        self.logger.info(f\"Parsnips extracting: `{file_path}`\")\n        parent_dir = file_path.parent\n\n        if force_parsnips_dir:\n            output_dir = parent_dir / '.parsnips'\n            if not output_dir.exists():\n                output_dir.mkdir(exist_ok=True)\n        else:\n            output_dir = output_dir or parent_dir\n\n        try:\n            code = file_path.read_text(encoding='utf-8')\n        except Exception as e:\n            self.logger.error(f\"Failed to read {file_path}: {e}\")\n            self._abort()\n\n        try:\n            atok = asttokens.ASTTokens(code, parse=True)\n        except SyntaxError as e:\n            self.logger.error(f\"Syntax error in {file_path}: {e}\")\n            self._abort()\n        except Exception as e:\n            self.logger.error(f\"AST parsing failed for {file_path}: {e}\")\n            self._abort()\n\n        file_swhid = Swhid.compute_content_swhid(code)\n        assert self.repo_root is not None\n        out_path = self.get_output_dir_for_file(self.repo_root, file_path)\n        out_path.mkdir(parents=True, exist_ok=True)\n\n        self.traversal_counter = 0\n        self._extract_node(atok, atok.tree, out_path, file_swhid, parent_lineno=0)\n\n\n    def get_output_dir_for_file(self, repo_root: Path, file_path: Path) -> Path:\n        relative = file_path.relative_to(repo_root)\n        path = repo_root / '.parsnips'\n        for part in relative.parts[:-1]:\n            path = path / f\"pdir_{part}\"\n        stem = file_path.stem\n        ext = file_path.suffix.lstrip('.') or 'txt'\n        safe_stem = re.sub(r'[^A-Za-z0-9_-]', '_', stem)\n        path = path / f\"pfile_{safe_stem}_{ext}\"\n        return path\n\n    def _extract_node(self, atok, node, parent_path, file_swhid, parent_lineno):\n        self.traversal_counter += 1\n\n        lineno = getattr(node, 'lineno', None)\n        effective_lineno = lineno if lineno is not None else parent_lineno\n        col_offset = getattr(node, 'col_offset', 0)\n        traversal_index = self.traversal_counter\n\n        node_type = type(node).__name__\n        node_label = self._get_node_label(atok, node)\n        folder_name = f\"EL{effective_lineno}C{col_offset}T{traversal_index}__{node_type}\"\n        node_path = parent_path / folder_name\n        node_path.mkdir(exist_ok=True)\n\n        try:\n            node_text = atok.get_text(node)\n        except Exception:\n            node_text = \"<source unavailable>\"\n\n        assert self.repo_root is not None\n        metadata = {\n            'type': node_type,\n            'label': node_label,\n            'text': node_text,\n            'lineno': lineno,\n            'effective_lineno': effective_lineno,\n            'col_offset': col_offset,\n            'file_swhid': file_swhid,\n            'source_path': str(self.current_file.relative_to(self.repo_root)),\n            'source_filename': self.current_file.name\n        }\n\n        with (node_path / 'node_metadata.json').open('w', encoding='utf-8') as f:\n            json.dump(metadata, f, indent=4, ensure_ascii=False)\n\n        for child in ast.iter_child_nodes(node):\n            self._extract_node(atok, child, node_path, file_swhid, parent_lineno=effective_lineno)\n\n    def _get_node_label(self, atok, node):\n        if isinstance(node, ast.FunctionDef):\n            return node.name\n        elif isinstance(node, ast.AsyncFunctionDef):\n            return node.name\n        elif isinstance(node, ast.ClassDef):\n            return node.name\n        elif isinstance(node, ast.arg):\n            return node.arg\n        elif isinstance(node, ast.Attribute):\n            return node.attr\n        elif isinstance(node, ast.Name):\n            return node.id\n        elif isinstance(node, ast.Import):\n            return 'import'\n        elif isinstance(node, ast.ImportFrom):\n            return f'from_{node.module or \"unknown\"}'\n        elif isinstance(node, ast.Assign):\n            targets = [re.sub(r'\\s+', '', atok.get_text(t)) for t in node.targets]\n            return '_'.join(targets)\n        elif isinstance(node, ast.Lambda):\n            return 'lambda'\n        elif isinstance(node, ast.Constant):\n            return str(node.value)\n        else:\n            return 'node'\n\n    def _abort(self):\n        if self.strict:\n            raise RuntimeError(\"Strict mode abort triggered\")",
    "lineno": null,
    "effective_lineno": 0,
    "col_offset": 0,
    "file_swhid": "swh:1:cnt:7d7f9763c68ed4e87e39a43c55e678cc521403782263666b937bb7581e2b1a37",
    "source_path": "src/parsnips/extractor.py",
    "source_filename": "extractor.py"
}