{
    "type": "Module",
    "label": "node",
    "text": "import json\nimport os\nimport sys\nimport unicodedata\nfrom pathlib import Path\n\nimport regex\n\nfrom parsnips.swhid import Swhid\n\n\nclass ParsnipsSearcher:\n\n    def __init__(self,\n                 logger,\n                 context_qualifiers: dict | None = None,\n                 repo_root: str | None = None,  \n                 use_unicode=False,\n                 use_regex=False, \n                 strict=False):\n        self.logger = logger\n        self.context_qualifiers = context_qualifiers\n        self.repo_root = repo_root\n        self.use_unicode = use_unicode\n        self.use_regex = use_regex\n        self.strict = strict\n    \n    def normalize_unicode(self, text):\n        \"\"\"Apply Unicode normalization (NFC) to text.\"\"\"\n        return unicodedata.normalize(\"NFC\", text)\n    \n    \n    def search(self, path: Path, search_text:str):\n        results = {}\n\n        if self.use_unicode:\n            search_text = self.normalize_unicode(search_text)\n\n        if self.use_regex:\n            pattern = search_text\n        else:\n            pattern = regex.escape(search_text)\n\n        try:\n            regex_compiled = regex.compile(pattern)\n        except regex.error as e:\n            self.logger.error(f\"Invalid regular expression: {e}\")\n            sys.exit(1)\n\n        # Determine starting directory\n        if path.is_file():\n            start_dir = path.parent\n        elif path.is_dir():\n            start_dir = path\n        else:\n            self.logger.error(f\"Invalid path: {path}\")\n            sys.exit(1)\n\n        found_parsnips = False\n\n        for root, dirs, files in os.walk(start_dir, topdown=True):\n            for d in dirs:\n                if d == '.parsnips':\n                    found_parsnips = True\n                    parsnips_dir = Path(root) / d\n                    for p_root, _, p_files in os.walk(parsnips_dir, topdown=True):\n                        for file in p_files:\n                            if file == \"node_metadata.json\":\n                                full_path = Path(p_root) / file\n                                try:\n                                    with open(full_path, encoding='utf-8') as f:\n                                        metadata = json.load(f)\n\n                                    text = metadata.get(\"text\", \"\")\n                                    text_to_search = self.normalize_unicode(text) if self.use_unicode else text\n\n                                    match = regex_compiled.search(text_to_search)\n                                    if match:\n                                        rel_path = os.path.relpath(full_path, start=Path.cwd())\n                                        metadata_str = json.dumps(metadata, sort_keys=True, ensure_ascii=False)\n                                        node_swhid_without_qualifiers = Swhid.compute_content_swhid(metadata_str)\n\n                                        # Compute fully qualified SWHID if context is available\n                                        if self.context_qualifiers and self.repo_root:\n                                            path_qual = os.path.relpath(full_path, start=self.repo_root)\n                                            node_swhid_with_qualifiers = (\n                                                f\"{node_swhid_without_qualifiers}\"\n                                                f\";anchor={self.context_qualifiers['anchor']}\"\n                                                f\";path=/{path_qual}\"\n                                            )\n                                        else:\n                                            node_swhid_with_qualifiers = None\n\n                                        # Extract named capture groups (or None)\n                                        regex_match_groups = match.groupdict() or None\n\n                                        results[rel_path] = {\n                                            \"search_text\": search_text, # either a literal or a regex pattern\n                                            \"search_used_regex\": self.use_regex,\n                                            \"search_used_unicode\": self.use_unicode,\n                                            \"search_regex_match_groups\": regex_match_groups,\n                                            \"node_swhid_without_qualifiers\": node_swhid_without_qualifiers,\n                                            \"node_swhid_with_qualifiers\": node_swhid_with_qualifiers,\n                                            \"node_metadata\": metadata\n                                        }\n\n\n                                except Exception as e:\n                                    msg = f\"Error reading {full_path}: {e}\"\n                                    if self.strict:\n                                        self.logger.error(msg)\n                                        sys.exit(1)\n                                    else:\n                                        self.logger.warning(msg)\n\n        if self.strict and not found_parsnips:\n            self.logger.error(\"Error: No .parsnips directories found.\")\n            sys.exit(1)\n\n        return results",
    "lineno": null,
    "effective_lineno": 0,
    "col_offset": 0,
    "file_swhid": "swh:1:cnt:2859b4782591ebc405d65df5998d21b4995fa95cc69bd30bb58dc542e1acc607",
    "source_path": "src/parsnips/searcher.py",
    "source_filename": "searcher.py"
}